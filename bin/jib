# @describe Jib helps the crane hoist the cargo.
# @version 0.1.0

# @cmd deploy an instance of the governance token - PREFER CLONING WHENEVER POSSIBLE
# @option --admin! the address entitled to call admin functions on the clone
# @option --name! the name of the token
# @option --symbol! the symbol for the token
# @option --cap! the maximum supply of the token
# @option --rpc-url=http://localhost:8545 The url of the RPC endpoint.
# @flag --ignore-deploy-warning
deployGovToken() {
  if [ $argc_ignore_deploy_warning ]; then
    forge script script/Deploy.s.sol:DeployScript \
      --rpc-url $argc_rpc_url --broadcast --verify -vvvv \
      --optimize --optimizer-runs 1000000 \
      --sig "deployGovernanceToken(address,string,string,uint256)" \
      -- $argc_admin "$argc_name" $argc_symbol $argc_cap
  else
    echo
    echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
    echo "!! WARNING: This will deploy a new Governance Token contract !!"
    echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
    echo
    echo " This is much more expensive than cloning. Avoid if possible."
    echo " If you are sure you want to deploy a new token, re-run this"
    echo " command with the --ignore-deploy-warning flag."
    echo
  fi
}

# @cmd deploy an instance of the membership token - PREFER CLONING WHENEVER POSSIBLE
# @option --admin! the address entitled to call admin functions on the clone
# @option --name! the name of the token
# @option --symbol! the symbol for the token
# @option --base-uri! the base uri for the token metadata
# @option --rpc-url=http://localhost:8545 The url of the RPC endpoint.
# @flag --ignore-deploy-warning
deployMemToken() {
  if [ $argc_ignore_deploy_warning ]; then
    forge script script/Deploy.s.sol:DeployScript \
      --rpc-url $argc_rpc_url --broadcast -vvvv \
      --optimize --optimizer-runs 1000000 \
      --sig "deployMembershipToken(address,string,string,string)" \
      -- $argc_admin "$argc_name" $argc_symbol $argc_base_uri
  else
    echo
    echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
    echo "!! WARNING: This will deploy a new Membership Token contract !!"
    echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
    echo
    echo " This is much more expensive than cloning. Avoid if possible."
    echo " If you are sure you want to deploy a new token, re-run this"
    echo " command with the --ignore-deploy-warning flag."
    echo
  fi
}

jqSelector() {
  echo "(.transactions[]|select(.contractName == \"$1\")|select(.transactionType == \"CREATE\")).contractAddress"
}

# @cmd verify the last membership token broadcast transaction
# @alias vmt
# @arg block-explorer-api-key! the api key for the block explorer
verifyLastMemToken() {
  BROADCAST_FILE=$(find broadcast -type f -print0 | xargs -0 stat --format '%Y :%y %n' | sort -nr | cut -d ' ' -f 5 | head -1)
  PROXY_ADMIN=$(jq -r "$(jqSelector ProxyAdmin)" $BROADCAST_FILE)
  TRANSPARENT_PROXY=$(jq -r "$(jqSelector TransparentUpgradeableProxy)" $BROADCAST_FILE)
  MEM_TOKEN=$(jq -r "$(jqSelector OrigamiMembershipToken)" $BROADCAST_FILE)
  CHAIN_ID=$(jq -r ".chain" $BROADCAST_FILE)
  forge verify-contract --chain-id $CHAIN_ID --num-of-optimizations 1000000 \
    --compiler-version v0.8.16+commit.07a7930e --watch \
    $PROXY_ADMIN ProxyAdmin $argc_block_explorer_api_key
  forge verify-contract --chain-id $CHAIN_ID --num-of-optimizations 1000000 \
    --compiler-version v0.8.16+commit.07a7930e --watch \
    $MEM_TOKEN OrigamiMembershipToken $argc_block_explorer_api_key
  forge verify-contract --chain-id $CHAIN_ID --num-of-optimizations 1000000 \
    --compiler-version v0.8.16+commit.07a7930e --watch \
    --constructor-args $(cast abi-encode "constructor(address,address,bytes)" $MEM_TOKEN $PROXY_ADMIN 0x) \
    $TRANSPARENT_PROXY TransparentUpgradeableProxy $argc_block_explorer_api_key
}

# @cmd upgrade a governance token
# @alias ugt
# @arg admin! the address of the proxy admin contract for the token
# @arg token! the address of the token to upgrade
# @option --rpc-url=http://localhost:8545 The url of the RPC endpoint.
upgradeGovToken() {
  forge script script/Upgrade.s.sol:UpgradeScript $argc_admin $argc_token \
    --rpc-url $argc_rpc_url --broadcast --verify -vvvv \
    --sig "upgradeGovernanceToken(address,address)" \
    --optimize --optimizer-runs 1000000
}

# @cmd upgrade a membership token
# @alias umt
# @arg admin! the address of the proxy admin contract for the token
# @arg token! the address of the token to upgrade
# @option --rpc-url=http://localhost:8545 The url of the RPC endpoint.
upgradeMemToken() {
  forge script script/Upgrade.s.sol:UpgradeScript $argc_admin $argc_token \
    --rpc-url $argc_rpc_url --broadcast --verify -vvvv \
    --sig "upgradeMembershipToken(address,address)" \
    --optimize --optimizer-runs 17500
}

# @cmd grant permissions to wallets in the specified file (one address per line) on the specified contract necessary to mint and revoke tokens
# @alias grant-permissions
# @arg contract! the address of the token contract
# @arg file! the path to the file containing the addresses to grant permissions to
# @option --rpc-url=http://localhost:8545 The url of the RPC endpoint.
grantPermissions() {
  REVOKER_ROLE="0xce3f34913921da558f105cefb578d87278debbbd073a8d552b5de0d168deee30"
  MINTER_ROLE="0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6"

  while read -r address; do
    cast send --rpc-url $argc_rpc_url --private-key $ADMIN_PRIVATE_KEY \
      $argc_contract "grantRole(bytes32,address)" $REVOKER_ROLE $address
    cast send --rpc-url $argc_rpc_url --private-key $ADMIN_PRIVATE_KEY \
      $argc_contract "grantRole(bytes32,address)" $MINTER_ROLE $address
  done <$argc_file
}

# @cmd deploy all current governor diamond facets
# @alias deploy-facets
# @option --rpc-url=http://localhost:8545 The url of the RPC endpoint.
# @flag --ignore-deploy-warning ignore the warning about deploying all facets
deployFacets() {
  if [ $argc_ignore_deploy_warning ]; then
    forge script script/Governor.s.sol:DeployGovernorFacets \
      --broadcast --verify --rpc-url $argc_rpc_url \
      --optimize --optimizer-runs 1000000
  else
    echo
    echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
    echo "!!   WARNING: This will deploy all Governor Diamond Facets   !!"
    echo "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-"
    echo
    echo " Unless this is the first deploy to a given chain, you probably"
    echo " don't want to do this. Facets are shared across all governor"
    echo " diamonds, so you almost never want to deploy _all_ of them."
    echo " If you are sure you want to deploy them, re-run this command"
    echo " with the --ignore-deploy-warning flag."
    echo
  fi
}

# @cmd deploy a governor diamond (sans facets) and a timelock controller
# @alias deploy-governor
# @arg path! the path to the governor diamond config
# @option --rpc-url=http://localhost:8545 The url of the RPC endpoint.
deployGovernor() {
  forge script script/Governor.s.sol:DeployGovernorInstance $argc_path \
    --optimize --optimizer-runs 1000000 --sig "run(string)" \
    --rpc-url $argc_rpc_url --broadcast --verify -vvvv
}

# @cmd output test coverage data for the contracts
# @alias cov
# @flag --no-open do not open the coverage report in the browser
coverage() {
  forge coverage --report lcov
  lcov -r lcov.info "test/*" \
    -r lcov.info "script/*" "src/governor/lib/*" "src/utils/*" \
    -o lcov-filtered.info
  genhtml -o coverage/ lcov-filtered.info
  rm lcov.info lcov-filtered.info
  [ $argc_no_open ] || open coverage/index.html
}

eval $(argc "$0" "$@")
